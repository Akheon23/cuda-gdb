
CHANGES TO GDB SOURCE CODE REQUIRED FOR CUDA SUPPORT

 All the required changes to the original GDB source code are marked with a
 comment of the form:
                            /* CUDA - keyword(s) */

 The related changes are marked with the same keyword. Each keyword is
 explained below.


/* CUDA - 64-bit register index */

  32 bits are not enough to encode the PTX register names generated by the
  compiler (%rNNNNNN), and we are limited to 2 digits only (%rNN). Use 64 bits
  instead.

/* CUDA - print_args_frame */

  New function added to print only the arguments of the function in the given
  frame. Required for the info cuda commands.

/* CUDA - cuda commands */

  New class of GDB commands starting with the "cuda" prefix.

/* CUDA - no address space management */

  CUDA-GDB does not support multiple address spaces. Those changes are required
  to reflect that limitation.

/* CUDA - cuda_objfile */

  CUDA device objfiles need to be marked as such because they require special
  treatment. Also, it allows identifying them from host objfiles and use the
  appropriate tools when using them. The CUDA and host objfiles are not built and
  parsed the same way.

/* CUDA - skip prologue */

  The code generated by NVCC may require special treatment. Until the compiler
  is fully transitioned to a new backend, mark objfiles whose code has been
  generated with the older backend. When generated with the older backend, on
  Tesla, there is no need to skip the prologue.

  This is a temporary workaround that should be removed for the 4.1 timeframe.

/* CUDA - auto breakpoints */

  Auto breakpoints are breakpoints automagically inserted at the entrance of
  all the CUDA kernels. It alleviates the user from setting those breakpoints
  manually.

  Those breakpoints are not listed with the other breakpoints, but they
  are hit like any other unconditional breakpoint. When 'set cuda auto ...' is
  set, all the breakpoints are inserted. The user has no control over each
  individual instance.

/* CUDA - extra signals */

  New signals used to handle exceptions raised by the CUDA devices. Some are
  reported by software detection, others are reported by hardware detection.

/* CUDA - extra registers */

  New raw and cooked registers added to support CUDA functions.

/* CUDA - extra frame info */

  Extra per-frame information required by CUDA infrastructure.

/* CUDA - frames */

  Necessary changes to make the CUDA frame unwinder functions work properly.
  Ideally, we would like those changes to be part of the architecture description.

/* CUDA - cuda-linux-nat.c */

  Cuda-linux-nat.c cannot be compiled on its own. It rides on top of
  i386-linux-nat.c and is included directly in the middle of that file (yuck!).

/* CUDA - version information */

  Print information about the debugger: CUDA support and CUDA toolkit version
  number.

/* CUDA - BFD architecture */

  At this point, there is no CUDA architecture in BFD. We use the i386
  architecture as a dummy architecture to register the CUDA gdbarch. The
  detection of duplicate BFD architectures had to be removed.

/* CUDA - breakpoints */

  Breakpoints set on device code have a built-in function name. Because the ELF
  image might not be loaded when a breakpoint is searched, we need that function
  name.

  Also b->loc->section becomes invalid if the ELF image is points to is
  unloaded. Therefore, that field should not be used if a breakpoint is of CUDA
  type.

/* CUDA - cleanup CUDA exception state */

  CUDA exceptions are set as part of the target wait and are cleared in resume.
  This state must be reset if the user is planning on restarting the app
  that has hit the exception.

/* CUDA - addr_size */

  While reading the CIE, the address size matters. It cannot be hard-coded as
  the address size for the debugger in case the user wants to debug a 32-bit
  binary on a 64-bit machine. It is a known GDB issue already documented with a
  comment in decode_frame_entry_1().
 
  The address size for a CIE is not specified. We must retrieve it from the
  .debug_info section instead. This change retrieves the address size from the
  first compilation unit in the .debug_info section of the same objfile. This fix
  is only used for CUDA objfiles.

/* CUDA - built-in cuda variables used in conditional breakpoints */

  If a built-in cuda variable (gridDim, blockIdx,...) is used in a
  conditional breakpoint set on a CUDA kernel and the breakpoint is hit
  on the host function before the breakpoint is promoted to a device
  breakpoint on a rerun, then we have nothing. When that happens, bail
  out instead of crashing.

  XXX use multiple breakpoint locations (one host, one device) to handle
  conditional breakpoints.

/* CUDA - Fix read_string */

  When reading strings from device memory, gdb uses a different path from
  normal read. And that path didn't correctly read CUDA device memory.
  Split cuda_{read, write}_memory into two functions and in partial_memory_read
  call the correct memory read function so that cuda-gdb can read device memory
  correctly.

/* CUDA - word size */

  To properly access the upward DYLD info on Mac OS X 10.7 (see solib-darwin.c),
  the word size used by the binary and dyld must be know. The CPU type is given
  by the BFD, whereas the CUDA layer interprets it to compute the word size (4 or
  8).

/* CUDA - iconv padding */

  On Mac OS X 10.7, Iconv may loop forever if we pass a pointer to an invalid
  string.  This happens when a char* pointer is decoded as a string although it
  is not a pointer to a string. The problem occurs when decoding the end of the
  string. It is probably caused by a decoding sequence that expects several
  characters with no more character left to decode.

  We cheat iconv by padding the string with 'iconv_padding' dummy characters.
  That will make sure that iconv returns, even if the decoded value is garbage.

/* CUDA - linux cleanup */

  On linux, when tearing down the inferior, GDB detects if the last wait
  returned due to detecting a fork/vfork, and attempts to kill the newly
  forked process first then waits for any children to change state with
  a "wait (&status)".  However, this process does not work if the cleanup
  is issued at a time prior to attaching to the newly forked process, or
  if the newly forked process has already exited.  More specifically, wait
  will not return in this situation, which causes a hang.  So, now the
  wait is predicated on a successful ptrace kill operation.

/* CUDA - filenames */

  Make sure to set up the basename, dirname, and fullname of symbol tables and
  partial symbol tables. If the basename of those tables is set to a fullname,
  breakpoint resolution may fail.

  Also, the fullname should only be used when absolute.

/* CUDA - special handling for assert */

  When a device side assert is hit, the last frame in the user code is a compiler
  generated function call to an internal syscall. In order to make the output
  cleaner for end users, this frame is handled specially. When stopped at
  the __assert_fail frame in device code, GDB will simply print the name of
  the function and will skip printing any arguments.
